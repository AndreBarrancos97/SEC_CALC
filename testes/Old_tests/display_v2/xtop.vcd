$date
	Mon Nov 18 07:58:26 2019
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module xtop_tb $end
$var wire 32 ! r0 [31:0] $end
$var wire 32 " r1 [31:0] $end
$var wire 32 # r10 [31:0] $end
$var wire 32 $ r11 [31:0] $end
$var wire 32 % r12 [31:0] $end
$var wire 32 & r13 [31:0] $end
$var wire 32 ' r14 [31:0] $end
$var wire 32 ( r15 [31:0] $end
$var wire 32 ) r2 [31:0] $end
$var wire 32 * r3 [31:0] $end
$var wire 32 + r4 [31:0] $end
$var wire 32 , r5 [31:0] $end
$var wire 32 - r6 [31:0] $end
$var wire 32 . r7 [31:0] $end
$var wire 32 / r8 [31:0] $end
$var wire 32 0 r9 [31:0] $end
$var wire 1 1 trap $end
$var wire 8 2 Led [7:0] $end
$var wire 4 3 Disp_sel [3:0] $end
$var wire 8 4 Disp [7:0] $end
$var reg 8 5 Sw [7:0] $end
$var reg 1 6 clk $end
$var reg 1 7 rst $end
$var integer 32 8 k [31:0] $end
$var integer 32 9 start_time [31:0] $end
$scope module uut $end
$var wire 4 : Btn [3:0] $end
$var wire 8 ; Sw [7:0] $end
$var wire 1 6 clk $end
$var wire 1 7 rst $end
$var wire 1 1 trap $end
$var wire 1 < regf_sel $end
$var wire 32 = regf_data_to_rd [31:0] $end
$var wire 9 > pc [8:0] $end
$var wire 1 ? mem_sel $end
$var wire 32 @ mem_data_to_rd [31:0] $end
$var wire 1 A leds_sel $end
$var wire 32 B instruction [31:0] $end
$var wire 1 C data_we $end
$var wire 32 D data_to_wr [31:0] $end
$var wire 32 E data_to_rd [31:0] $end
$var wire 1 F data_sel $end
$var wire 10 G data_addr [9:0] $end
$var wire 1 H cprt_sel $end
$var wire 8 I Led [7:0] $end
$var wire 4 J Disp_sel [3:0] $end
$var wire 8 K Disp [7:0] $end
$scope module addr_decoder $end
$var wire 1 F sel $end
$var wire 32 L regf_data_to_rd [31:0] $end
$var wire 32 M mem_data_to_rd [31:0] $end
$var wire 10 N addr [9:0] $end
$var reg 1 H cprt_sel $end
$var reg 32 O data_to_rd [31:0] $end
$var reg 1 A leds_sel $end
$var reg 1 ? mem_sel $end
$var reg 1 < regf_sel $end
$var reg 1 1 trap_sel $end
$upscope $end
$scope module controller $end
$var wire 1 P alu_arith_ops $end
$var wire 1 Q alu_imm_ops $end
$var wire 1 R alu_logic_ops $end
$var wire 1 S alu_mem_ops $end
$var wire 1 T alu_ops $end
$var wire 32 U and_res [31:0] $end
$var wire 1 V branch_ops $end
$var wire 1 6 clk $end
$var wire 1 W imm_ops $end
$var wire 1 X load_imm_ops $end
$var wire 1 Y load_mem_ops $end
$var wire 1 Z load_ops $end
$var wire 32 [ mem_data_from [31:0] $end
$var wire 32 \ mem_data_to [31:0] $end
$var wire 1 F mem_sel $end
$var wire 1 C mem_we $end
$var wire 1 7 rst $end
$var wire 1 ] store_mem_ops $end
$var wire 32 ^ xor_res [31:0] $end
$var wire 4 _ opcode [3:0] $end
$var wire 32 ` instruction [31:0] $end
$var wire 32 a imm [31:0] $end
$var reg 32 b adder_res [31:0] $end
$var reg 1 c alu_carry $end
$var reg 1 d alu_negative $end
$var reg 1 e alu_overflow $end
$var reg 32 f alu_result [31:0] $end
$var reg 1 g carry_res_n $end
$var reg 32 h carry_res_n_1 [31:0] $end
$var reg 10 i mem_addr [9:0] $end
$var reg 32 j operand [31:0] $end
$var reg 9 k pc [8:0] $end
$var reg 32 l regA [31:0] $end
$var reg 32 m regB [31:0] $end
$var reg 3 n regC [2:0] $end
$upscope $end
$scope module cprint $end
$var wire 1 6 clk $end
$var wire 8 o data_in [7:0] $end
$var wire 1 p sel $end
$upscope $end
$scope module disp_test $end
$var wire 8 q bin [7:0] $end
$var wire 1 6 clock_100Mhz $end
$var wire 1 7 reset $end
$var wire 1 r sgn $end
$var wire 1 s one_second_enable $end
$var wire 2 t LED_activating_counter [1:0] $end
$var reg 4 u Anode_Activate [3:0] $end
$var reg 12 v bcd [11:0] $end
$var reg 14 w binary [13:0] $end
$var reg 7 x disp [6:0] $end
$var reg 16 y displayed_number [15:0] $end
$var reg 4 z hundreds [3:0] $end
$var reg 4 { j [3:0] $end
$var reg 27 | one_second_counter [26:0] $end
$var reg 4 } ones [3:0] $end
$var reg 20 ~ refresh_counter [19:0] $end
$var reg 30 !" shifter [29:0] $end
$var reg 4 "" tens [3:0] $end
$var reg 4 #" thousands [3:0] $end
$var integer 32 $" i [31:0] $end
$upscope $end
$scope module leds $end
$var wire 1 6 clk $end
$var wire 1 A led_sel $end
$var wire 1 7 reset $end
$var wire 8 %" sw [7:0] $end
$var reg 8 &" led [7:0] $end
$upscope $end
$scope module ram $end
$var wire 1 6 clk $end
$var wire 9 '" data_addr [8:0] $end
$var wire 9 (" data_addr_int [8:0] $end
$var wire 1 )" data_en_int $end
$var wire 32 *" data_in [31:0] $end
$var wire 32 +" data_in_int [31:0] $end
$var wire 32 ," data_out [31:0] $end
$var wire 1 ? data_sel $end
$var wire 1 C data_we $end
$var wire 1 -" data_we_int $end
$var wire 1 ." instr_en $end
$var wire 9 /" pc [8:0] $end
$var reg 32 0" data_out_int [31:0] $end
$var reg 32 1" instruction [31:0] $end
$upscope $end
$scope module regf $end
$var wire 4 2" addr [3:0] $end
$var wire 1 6 clk $end
$var wire 32 3" data_in [31:0] $end
$var wire 1 < sel $end
$var wire 1 C we $end
$var wire 32 4" data_out [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx 4"
bx 3"
bx 2"
bx 1"
bx 0"
bx /"
1."
x-"
bx ,"
bx +"
bx *"
x)"
bx ("
bx '"
bx &"
b0 %"
b1110 $"
b110 #"
b0 ""
b11000100000000000000000000000 !"
bx ~
b0 }
bx |
b1000 {
b10 z
bx y
bx x
b1111000 w
b0 v
bx u
bx t
xs
1r
b0 q
xp
bx o
bx n
bx m
bx l
bx k
bx j
bx i
bx h
xg
bx f
xe
xd
xc
bx b
bx a
bx `
bx _
bx ^
x]
bx \
bx [
xZ
xY
xX
xW
xV
bx U
xT
xS
xR
xQ
xP
bx O
bx N
bx M
bx L
b0xxxxxxx K
bx J
bx I
xH
bx G
xF
bx E
bx D
xC
bx B
xA
bx @
x?
bx >
bx =
x<
b0 ;
bz :
bx 9
bx 8
07
16
b0 5
b0xxxxxxx 4
bx 3
bx 2
x1
bx 0
bx /
bx .
bx -
bx ,
bx +
bx *
bx )
bx (
bx '
bx &
bx %
bx $
bx #
bx "
bx !
$end
#5000
06
#10000
16
#11000
0s
b1000000 4
b1000000 K
b1000000 x
b1110 3
b1110 J
b1110 u
b10 ""
b1001 z
b0 #"
b1110 $"
b10010010000000000000000000 !"
0e
0d
0c
b0 f
b0 b
0g
b0 h
b0 ^
b0 U
b0 o
b0 j
b0 t
b0 >
b0 k
b0 /"
b0 +"
b0 D
b0 \
b0 *"
b0 3"
b0 l
b0 m
b0 n
b0 |
b0 y
b0 ~
b0 2
b0 I
b0 &"
17
#15000
06
#20000
0F
b0 =
b0 L
b0 4"
b0 E
b0 O
b0 [
b1 b
b1 h
b1 ^
b1 2"
b1 ("
b1 '"
01
0H
0<
0)"
0?
0A
b1 j
b1 G
b1 N
b1 i
0S
0T
0p
1Z
1W
b1 a
0V
0R
0P
0Q
0-"
0C
0]
0Y
1X
b110 _
b1100000000000000000000000000001 B
b1100000000000000000000000000001 `
b1100000000000000000000000000001 1"
16
#21000
b10000 8
b10101 9
07
#25000
06
#30000
b10 b
b10 h
b0 ^
b1 U
b1 o
b1 >
b1 k
b1 /"
b1 +"
b1 D
b1 \
b1 *"
b1 3"
b1 l
b1 |
b1 ~
16
#35000
06
#40000
1A
1F
b1 b
b1 h
b1 ^
b0 U
b1100 2"
b10111100 ("
b10111100 '"
b0 j
b1010111100 G
b1010111100 N
b1010111100 i
0Z
0W
b1010111100 a
1-"
1C
1]
0X
b1001 _
b10 ~
b10 |
b10 >
b10 k
b10 /"
b10010000000000000000001010111100 B
b10010000000000000000001010111100 `
b10010000000000000000001010111100 1"
16
#45000
06
#50000
0F
b0 E
b0 O
b0 [
b110110 b
b110110 h
b110100 ^
b1 U
b101 2"
b110101 ("
b110101 '"
0)"
0?
0A
b110101 j
b110101 G
b110101 N
b110101 i
1Z
1W
b110101 a
0-"
0C
0]
1X
b110 _
b11 >
b11 k
b11 /"
b11 |
b11 ~
b1100000000000000000000000110101 B
b1100000000000000000000000110101 `
b1100000000000000000000000110101 1"
16
#55000
06
#60000
11
1F
b1111 2"
b111111111 ("
b111111111 '"
b0 j
b1111111111 G
b1111111111 N
b1111111111 i
0Z
0W
b111111111111111 a
1-"
1C
1]
0X
b110101 b
b110101 h
b110101 ^
b0 U
b110101 o
b1001 _
b100 ~
b100 |
b110101 +"
b110101 D
b110101 \
b110101 *"
b110101 3"
b110101 l
b100 >
b100 k
b100 /"
b10010000000000000111111111111111 B
b10010000000000000111111111111111 `
b10010000000000000111111111111111 1"
16
#65000
06
#70000
0F
b0 E
b0 O
b0 [
b0 2"
b0 ("
b0 '"
0)"
0?
01
b0 G
b0 N
b0 i
1Z
1W
b0 a
0-"
0C
0]
1X
b110 _
b101 >
b101 k
b101 /"
b101 |
b101 ~
b1100000000000000000000000000000 B
b1100000000000000000000000000000 `
b1100000000000000000000000000000 1"
16
